---
title: 消息传递并行—MPI
date: 2025-06-01 10:34:58
updated: 2025-05-30 10:16:09
categories:
  - [服务器&嵌入式平台操作, 工具]
tags:
permalink: 消息传递并行—mpi/
---

MPI是一个消息传递库接口规范，这个定义的所有部分都很重要。MPI主要针对消息传递并行编程模型，其中数据通过每个进程上的协作操作从一个进程的地址空间移动到另一个进程的地址空间。在集合操作、远程内存访问操作、动态进程创建和并行I/O等方面提供了对“经典”消息传递模型的扩展。MPI是一个规范，不是一个实现；有多个MPI的实现。这个规范是一个库接口；MPI不是一种语言，所有MPI操作都表达为函数、子程序或方法，根据适当的语言绑定，对于C和Fortran来说，这些是MPI标准的一部分。这个标准是通过一个由并行计算供应商、计算机科学家和应用开发者组成的社区的开放过程定义的。
## 在Python+MPI开发环境中安装

> [!NOTE] 操作环境
> 香橙派4-lts Orange Pi 3.0.6 Buster with Linux 4.4.179-rk3399
> python3.9.19 ~~pip24.0~~ pip24.3.1

### MPICH的安装
$Last Edited：2024.12.23/19:50$
___

参考：[两小时入门MPI与并行计算（二）：MPI的安装与配置 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/356705583)
[Downloads | MPICH](https://www.mpich.org/downloads/)
MPICH与OpenMPI是对MPI标准的具体实现。

1. 安装前先检查是否有需要的编译器：
```bash
which gcc 
which gfortran 
```
输出安装目录时，可以进行下一步安装。否则需要先安装好这两个编译器。

2. 下载合适的安装文件。
我选择的是用deb包安装（直接用apt安装应该也可以）。因为是Debian系统，可以从这个网址下载[Debian -- 软件包下载地址选择 -- mpich_3.3-3_arm64.deb](https://packages.debian.org/buster/arm64/mpich/download)也可以从网站上找到其他版本。此外，也可以看到mpich依赖的软件包：[Debian -- 在 buster 中的 mpich 软件包详细信息](https://packages.debian.org/buster/mpich)
复制下载地址，输入:
```bash
wget http://ftp.cn.debian.org/debian/pool/main/m/mpich/mpich_3.3-3_arm64.deb
```

下载完成后，安装deb包：
```bash
sudo dpkg -i mpich_3.3-3_arm64.deb
```

3. 上述2步相当于：(可替代)
```bash
sudo apt install mpich
```

4. 缺失的依赖用以下指令安装：
```bash
apt --fix-broken install
```

接下来还需要执行：
```bash
sudo apt install libmpich-dev
```

5. 测试程序
来源于：[02-第一个MPI程序：Hello world_头歌第2关:使用mpi运行"hello world-CSDN博客](https://blog.csdn.net/Sunshine8430/article/details/80982847)
创建一个helloworld文件：
```bash
vim helloworld.c
```

内容如下：
```C `include` <mpi.h> `include` <stdio.h>

int main(int argc, char** argv){
    //初始化MPI环境
    MPI_Init(NULL, NULL);

    //获取进程数
    int world_size;
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);

    //获取进程的等级
    int world_rank;
    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);

    //获取进程的名字
    char processor_name[MPI_MAX_PROCESSOR_NAME];
    int name_len;
    MPI_Get_processor_name(processor_name, &name_len);

    //打印helloworld
    printf("Hello world from processor %s, rank %d out of %d processors\n",processor_name, world_rank, world_size);

    //关闭MPI环境
    MPI_Finalize();
}
```
复制进去，保存退出。

编译文件：
```bash
mpicc helloworld.c -o helloworld
```
成功编译后，目录中会出现helloworld文件。

运行：
```bash
mpirun -np 4 ./helloworld
```

结果如下：
```text
Hello world from processor orangepi4-lts, rank 1 out of 4 processors
Hello world from processor orangepi4-lts, rank 2 out of 4 processors
Hello world from processor orangepi4-lts, rank 3 out of 4 processors
Hello world from processor orangepi4-lts, rank 0 out of 4 processors
```
### mpi4py的安装
$Last Edited：2024.12.30/15:24$
___

参考官方文档：[Installation — MPI for Python 3.1.6 documentation (mpi4py.readthedocs.io)](https://mpi4py.readthedocs.io/en/stable/install.html#testing)

1. 直接用pip安装：
```bash
python -m pip install mpi4py
```
报错缺什么包就装什么，安装不上也有可能是版本问题，可以换一个版本的Python和pip试试。

2. 检查版本
```bash
pip show mpi4py
```

或者
```bash
pip list
```
我安装的是4.0.1，与pip-24.3.1匹配

显示
```text
root@pi1:~# pip show mpi4py
Name: mpi4py
Version: 4.0.1
Summary: Python bindings for MPI
Home-page: https://mpi4py.github.io
Author: Lisandro Dalcin
Author-email: dalcinl@gmail.com
License: BSD-3-Clause
Location: /usr/local/python3/lib/python3.9/site-packages
Requires: 
Required-by: 
```

3. 测试1
用到了`mpi4py.bench` 模块中的具体基准测试，输入指令：
```bash
mpiexec -n 5 python -m mpi4py.bench helloworld
```
- `-n 5`：这个选项指定了要启动的进程数，这里是5个。
- `python`：这是您想要使用的Python解释器。想在虚拟环境运行就是虚拟环境解释器的路径==./myenv/bin/python==
- `-m`：这个选项用于运行Python模块。

输出：
```text
Hello, World! I am process 0 of 5 on orangepi4-lts.
Hello, World! I am process 1 of 5 on orangepi4-lts.
Hello, World! I am process 2 of 5 on orangepi4-lts.
Hello, World! I am process 3 of 5 on orangepi4-lts.
Hello, World! I am process 4 of 5 on orangepi4-lts.
```

4. 测试2
来源于：[Python使用MPI实现分布式计算（mpi4py） - 知乎](https://zhuanlan.zhihu.com/p/157804393)

创建一个mpi_test.py文件，写入：
```python
from mpi4py import MPI

comm = MPI.COMM_WORLD
size = comm.Get_size()
rank = comm.Get_rank()

if rank == 0:
    msg = 'Hello, world'
    comm.send(msg, dest=1)
elif rank == 1:
    s = comm.recv()
    print("rank %d: %s" % (rank, s))
else:
    print("rank %d: idle" % (rank))
```

输入指令：
```bash
mpiexec -np 8 python mpi_test.py
```

输出：
```text
rank 3: idle
rank 4: idle
rank 5: idle
rank 7: idle
rank 2: idle
rank 6: idle
rank 1: Hello, world
```

## 在集群中配置MPI

> [!NOTE] 操作环境
> 同一局域网下的多台香橙派4-lts Orange Pi 3.0.6 Buster with Linux 4.4.179-rk3399
> ip地址为192.168.0.110-192.168.0.113
### 实现SSH免密登录
详见[SSH#SSH免密登录](SSH#SSH免密登录)

### 多主机并行测试
$Last Edited：2024.12.31/10:32$
___

参考：[MPI多机器实现并行计算 - earth_houge - 博客园](https://www.cnblogs.com/earthhouge/p/9275250.html)
[利用MPI多节点分布式并行计算PI实验报告_多节点并行计算-CSDN博客](https://blog.csdn.net/lhc121386/article/details/111600228)
[mpich/doc/wiki/how_to/Using_the_Hydra_Process_Manager.md at main · pmodels/mpich](https://github.com/pmodels/mpich/blob/main/doc/wiki/how_to/Using_the_Hydra_Process_Manager.md)
前置条件：==MPI在单机正常运行、多主机之间可以相互SSH免密登录、多主机的mpich和用到的库版本相同==。（只是单方面免密登录会报错，但只要主机和从机间双向免密，多个从机相互之间不配置免密似乎也可行）

1. 创建一个文件，我命名的是mpi_hosts，直接在root目录下创建的。
```bash
vim mpihosts
```

输入==主机名称:运行的进程数==，如:
```text
pi1:4
pi2:4
pi3:4
pi4:4
```
注意上述==主机名称==要和前面==ip映射的主机名称==对应。进程会按照主机名称顺序循环执行。

做过实验，在pi4运行程序，而pi1不知道主机名到ip的映射，会出现报错：
```text
[proxy:0:0@pi1] HYDU_sock_connect (utils/sock/sock.c:145): unable to get host address for pi4 (1)
[proxy:0:0@pi1] main (pm/pmiserv/pmip.c:183): unable to connect to server pi4 at port 34078 (check for firewalls!)
```
*将上述mpi_hosts中的pi4改为局域网ip*或者*修改pi1的主机映射*才可以正常运行。值得一提的是，如果使用前一种方法，在pi4上输出的结果仍显示pi4，说明这个名称为实际运行进程主机的主机名。

2. 利用前面MPICH的hellworld程序测试：
```bash
mpirun -n 6 -f mpi_hosts ./helloworld
```

注意，多机运行程序时，要保证==程序在每个机器的相同目录下都存在==
否则会报错：
```text
[proxy:0:0@pi3] HYDU_create_process (utils/launch/launch.c:74): execvp error on file ./helloworld (No such file or directory)
```

3. 只用pi3和pi4两个主机，在pi4上运行时输出如下：
```text
Hello world from processor pi4, rank 5 out of 6 processors
Hello world from processor pi4, rank 4 out of 6 processors
Hello world from processor pi3, rank 1 out of 6 processors
Hello world from processor pi3, rank 2 out of 6 processors
Hello world from processor pi3, rank 3 out of 6 processors
Hello world from processor pi3, rank 0 out of 6 processors
```

4. 试了一下修改pi3的程序再运行。
改了print函数中的内容：
```text
Hello world from processor pi4, rank 5 out of 6 processors
Hello world from processor pi4, rank 4 out of 6 processors
I changed Hello world from processor pi3, rank 3 out of 6 processors
I changed Hello world from processor pi3, rank 2 out of 6 processors
I changed Hello world from processor pi3, rank 1 out of 6 processors
I changed Hello world from processor pi3, rank 0 out of 6 processors
```

改变量名，也没出现问题。甚至多机之间数组大小不匹配，只要程序本身没有语法问题也可以运行，只是最后会出现乱码（用numpy做gather试的），所以代码内部检查还是有必要的。

## 为MPI并行任务优化集群

> [!NOTE] 操作环境
> 同一局域网下的多台香橙派4-lts Orange Pi 3.0.6 Buster with Linux 4.4.179-rk3399
> ip地址为192.168.0.110-192.168.0.113

### 时间同步
$Last Edited：2025.01.14/12:11$
___

配置NTP服务器以同步局域网内的设备主要分为两部分：配置NTP服务器（服务端）和配置NTP客户端。以下是详细的步骤和配置方法：
#### 配置NTP服务器（服务端）
选择pi1（IP地址为192.168.0.110）作为NTP服务器。

1. 安装NTP服务
在pi1上安装NTP服务（如果尚未安装）：
```bash
sudo apt-get install ntp
```

2. 编辑NTP配置文件
编辑`/etc/ntp.conf`文件，进行以下配置：
```bash
sudo nano /etc/ntp.conf
```

3. 配置内容
```text
# 使用公共NTP服务器作为时间源
server ntp.ntsc.ac.cn iburst
 `本地时间对外对时`
server 127.127.1.0
fudge 127.127.1.0 stratum 5

# 允许本地网络的机器同步时间
restrict 192.168.0.0 mask 255.255.255.0 nomodify notrap

broadcast pi2
broadcast pi3
```
4. 保存并退出编辑器
保存并退出编辑器后，重启NTP服务使配置生效：
```bash
sudo service ntp restart
```

#### 配置NTP客户端
假设pi2、pi3、pi4（IP地址分别为192.168.0.111、192.168.0.112、192.168.0.113）作为NTP客户端。

1. 安装NTP服务
在每个客户端上安装NTP服务（如果尚未安装）：
```bash
sudo apt-get update
sudo apt-get install ntp
```

2. 编辑NTP配置文件
编辑`/etc/ntp.conf`文件，进行以下配置：
```bash
sudo nano /etc/ntp.conf
```

3.  配置内容
这里我还将配置文件中`pool`还有其他`server`的行注释掉了。
```text
# 从pi1同步时间
server pi1

disable auth
broadcastclient
```

4. 保存并退出编辑器
保存并退出编辑器后，重启NTP服务使配置生效：
```bash
sudo service ntp restart
```

5. 在客户端验证
在pi2、pi3、pi4上执行`ntpq -p`命令，查看是否成功与pi1同步时间：
```bash
ntpq -p
```

```text
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
*pi1             202.112.29.82    2 u   56  512  377    0.819    0.321   0.119
```
输出结果中`remote`应显示为pi1的IP地址，`refid`应显示为pi1的上级时间源IP或域名，`st`应为较低的值（如3或4），`reach`应为非0值（如377），表示成功同步。

###  NFS共享文件
受内核限制